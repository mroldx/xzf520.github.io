<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从字节码说起，分析类加载的过程，并结合内存布局，讲解对象创建与垃圾回收]]></title>
    <url>%2F2020%2F05%2F15%2Fjava%2F%E8%B5%B0%E8%BF%9BJVM%2F</url>
    <content type="text"><![CDATA[走进JVM从字节码说起，分析类加载的过程，并结合内存布局，讲解对象创建与垃圾回收 一.字节码1.加载或存储指令在某个栈帧中，通过指令操作数据在虚拟机栈的局部变量表与操作栈之间来回传输，常用指令如下： (1) 将局部变量加载到操作栈中。如ILOAD (将int类型的局部变量压入栈) 和ALOAD (将对象引用的局部变量压入栈)等。 (2)从操作栈顶存储到局部变量表。如ISTORE、 ASTORE等。 (3)将常量加载到操作栈顶，这是极为高频使用的指令。如ICONST、 BIPUSH、SIPUSH、LDC等。 ●ICONST加载的是-1 ~ 5的数( ICONST与BIPUSH的加载界限)。 ●BIPUSH，即Byte Immediate PUSH，加载-128 ~ 127 之间的数。 ●SIPUSH，即Short Immediate PUSH，加载-32768 ~ 32767之间的数。 ●LDC，即Load Constant， 在-2147483648 ~ 2147483647或者是字符串时,JVM采用LDC指令压入栈中。 2.运算指令对两个操作栈帧.上的值进行运算，并把结果写入操作栈顶，如IADD、IMUL等。 3.类型转换指令显式转换两种不同的数值类型。如I2L、D2F等。 4.对象创建与访问指令根据类进行对象的创建、初始化、方法调用相关指令，常见指令如下: (1)创建对象指令。如NEW、NEWARRAY等。 (2)访问属性指令。如GETFIELD、 PUTFIELD、 GETSTATIC等。 (3)检查实例类型指令。如INSTANCEOF、 CHECKCAST等。 5.操作栈管理指令JVM提供了直接控制操作栈的指令，常见指令如下:(1 )出栈操作。如POP即一个元素，POP2即两个元素。(2)复制栈项元素并压入栈。如DUP。 6.方法调用与返回指令常见指令如下:( 1 ) INVOKEVIRTUAL指令:调用对象的实例方法。(2 ) INVOKESPECIAL指令:调用实例初始化方法、私有方法、父类方法等。(3) INVOKESTATIC指令: 调用类静态方法。(4) RETURN指令:返回VOID类型。 7.同步指令JVM使用方法结构中的ACC_ SYNCHRONIZED标志同步方法，指令集中有.MONITORENTER和MONITOREXIT支持synchronized语义。除字节码指令外，还包含一些额外信息。例如，LINENUMBER存储了字节码与源码行号的对应关系，方便调试的时候正确地定位到代码的所在行;LOCALVARIABLE存储当前方法中使用到的局部变量表。 ​ 字节码必须通过类加载过程加载到JVM环境后，才可以执行。执行有三种模式:第一，解释执行;第二，JIT编译执行;第三，JIT编译与解释混合执行(主流JVM .默认执行模式)。 混合执行模式的优势在于解释器在启动时先解释执行,省去编译时间。随着时间推进，JVM通过热点代码统计分析，识别高频的方法调用、循环体、公共模块等，基于强大的JIT动态编译技术，将热点代码转换成机器码，直接交给CPU执行。JIT的作用是将Java字节码动态地编译成可以直接发送给处理器指令执行的机器码。 二.类加载过程在冯.诺依曼定义的计算机模型中，任何程序都需要加载到内存才能与CPU进行交流。字节码.class文件同样需要加载到内存中，才可以实例化类。“ 兵马未动，粮草先行。”ClassLoader正是准备粮草的先行军，它的使命就是提前加载.class 类文件到内存中。在加载类时，使用的是Parents Delegation Model,译为双亲委派模型，某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 委托机制的意义 — 防止内存中出现多份同样的字节码比如两个类A和类B都要加载System类： 如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。 如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。 JVM预定义的三种类型类加载器： 启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将 &lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 系统（System）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。 除了以上列举的三种类加载器，还有一种比较特殊的类型 — 线程上下文类加载器。 ​ Java的类加载器是-个运行时核心基础设施模块，主要是在启动之初进行类的Load、Link 和Init,即加载、链接、初始化。​ 第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类等，然后创建对应类的java.lang.Class实例。​ 第二步，Link阶段包括验证、准备、解析三个步骤。验证是更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等;准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。​ 第三步，Init阶段执行类构造器 方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。 类加载是一个将.class字节码文件实例化成Class对象并进行相关初始化的过程。在这个过程中，JVM会初始化继承树上还没有被初始化过的所有父类，并且会执行这个链路.上所有未执行过的静态代码块、静态变量赋值语句等。某些类在使用时，也可以按需由类加载器进行加载。 在学习了类加载器的实现机制后，知道双亲委派模型并非强制模型，用户可以自定义类加载器，在什么情况下需要自定义类加载器呢? (1)隔离加载类。在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如，阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。 (2)修改类加载方式。类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载。 (3)扩展加载源。比如从数据库、网络，甚至是电视机机顶盒进行加载。 (4)防止源码泄露。Java代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins+Maven+Git(GitLab)持续集成Java项目]]></title>
    <url>%2F2020%2F05%2F01%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2FJenkins%2BMaven%2BGit(GitLab)%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90Java%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Jenkins+Maven+Git(GitLab)持续集成Java项目一、前言1、本文主要内容 Jenkins+SSH获取Gitlab代码 Jenkins+Maven构建Java(Spring Boot)项目配置 Jenkins发布Spring Boot项目：远程服务器端配置 Jenkins发布Spring Boot项目：pom.xml编译配置 Jenkins+SSH将构建输出结果发布到远程服务器并启动应用 2、环境信息 服务器 服务器名 操作系统 IP 说明 GitLab CentOS 7 192.168.56.160 部署GitLab社区版 Jenkins CentOS 7 192.168.56.150 部署Jenkins Server CentOS 7 192.168.88.155 部署Java项目 软件 工具/环境 版本 Jenkins 2.176.2 Maven 3.6.1 GitLab GitLab CE 12.1.2 JDK 1.8.0_181 3、基础准备 GitLab部署 参考：https://ken.io/note/centos7-gitlab-install-tutorial 配置GitLab访问地址为：http://192.168.56.160 Jenkins部署 参考：https://ken.io/note/centos7-jenkins-install-tutorial 二、 Java应用部署服务器1、部署JDK8参考：https://ken.io/note/centos-java-setup 将jdk1.8.0_181部署在目录/usr/java/ 部署完成后，jdk的根目录就是：/usr/java/jdk1.8.0_181/ 2、开放端口123#开放1000到9999的端口sudo firewall-cmd --add-port=1000-9999/tcp --permanentsudo firewall-cmd --reload 3、创建应用部署目录12345#创建目录sudo mkdir -p /webroot#授权sudo chown -R app:app /webroot 三、Jenkins环境准备在配置构建任务之前，我们需要在Jenkins服务器配置Maven、Git环境 1、Maven安装 下载&amp;解压 12345678cd /home/downloads#下载sudo wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.1/binaries/apache-maven-3.6.1-bin.tar.gz#解压到指定目录sudo mkdir -p /usr/mavensudo tar -zvxf apache-maven-3.6.1-bin.tar.gz -C /usr/maven 配置环境变量 123456789101112#修改/etc/profilesudo vi /etc/profile#在文件末尾写入以下内容export MAVEN_HOME=/usr/maven/apache-maven-3.6.1export PATH=$MAVEN_HOME/bin:$PATH#使更改生效source /etc/profile#测试mvn -version 配置Maven仓库 为了保证jar包的下载速度，修改maven配置使用国内镜像 12345678910111213141516171819202122232425262728293031323334353637383940#进入Maven根目录cd $MAVEN_HOME#备份配置文件sudo mv conf/settings.xml conf/settings.xml.bak#新建配置文件sudo vi settings.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus-163&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus 163&lt;/name&gt; &lt;url&gt;http://mirrors.163.com/maven/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 2、Git Client安装 安装 1sudo yum install -y git 密钥准备 12#生成密钥ssh-keygen -t rsa 将公钥添加到GitLab 12#查看公钥cat ~/.ssh/id_rsa.pub 访问GitLab：http://192.168.56.150:/profile/keys，添加公钥 添加Git SSH凭据 后面配置Jenkins构建任务代码仓库时需要用到 12#查询SSH私钥cat ~/.ssh/id_rsa 访问:/credentials/store/system/domain/_/newCredentials 直接进入凭据添加界面 类型选择：SSH Username with private key jenkins-credentials-gitlab-key 3、插件安装 插件列表 插件名 版本 说明 Git 3.11.0 使用Git访问远程仓库 Maven Integration 3.3 使用Maven进行编译等 Publish Over SSH 1.20.1 用于将编译结果发布到远程服务器 安装说明 访问： 1http://192.168.56.150:8080/pluginManager/available Ctrl+F搜索插件名，勾选后，进行安装 安装完成后，重启jenkins 1sudo systemctl restart jenkins 4、Jenkins插件/环境配置在菜单：系统管理-&gt;全局工具配置中对插件相关工具进行配置 Publish over SSH 然后在菜单：系统管理-&gt;系统设置对Publish over SSH进行设置 主要配置项说明： 配置项 说明 Name 服务器名，随便写，方便记忆即可 Hostname 服务器IP，或者可以被正常解析的服务器名/域名 Username 用于登录的账号 Remote Dictionary 远程目录，绝对路径 Passphrase/Password 密码 Port SSH端口 配置完成后可以点击Test Configuration进行连接测试 四、Jenkins构建任务1、示例项目准备 如果已经有现成项目可忽略此步骤 访问：http://192.168.56.150/projects/new创建项目:helloworld 创建SpringBoot应用 参考：https://ken.io/note/springboot-course-basic-helloworld 创建SpringBoot应用 参数 值 Maven模板 maven-archetype-webapp GroupId io.ken.tutorial ArtifactId helloworld Version 1.0 配置编译选项 修改pom.xml，以满足编译要求 123456789101112131415161718192021222324&lt;build&gt; &lt;finalName&gt;helloworld&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置application.yml，配置应用端口为8081 12server: port: 8081 项目准备完成后，在GitLab账号ken下面创建项目helloworld并将刚才创建的文件提交上去 示例代码：https://gitlab.com/ken-io/springboot-helloworld 2、Jenkins任务创建jenkins-create-job-maven-springboot 选择：构建一个maven项目，然后确定即可 3、配置源代码管理jenkins-create-job-maven-springboot-sourcecode-git-ssh 这里我们选择Git，并配置SSH Git地址，选择之前创建好的凭据/密钥 4、Publish over SSH配置jenkins-create-job-maven-springboot-buildenv-publishoverssh 配置项说明： 配置项 值 说明 Name appserver SSH Server名称，根据之前配置选择即可 Source files target/*.jar 需要传输的文件，支持通配符，编译文件默认都在项目根目录下的target目录中 Remove prefix target 移除匹配到的文件路径的前缀，如果留空，会在远程服务器上创建对应的目录 Remote directory helloworld/ 远程服务器上的项目目录，该目录会被创建在Publish over SSH配置的远程根目录中(/webroot) Exec command — 文件传输到远程服务器后执行的命令 命令示例： 1234567891011121314151617181920212223242526272829APP_NAME=helloworld.jarcd /webroot/helloworldmkdir -p logs#找到包含AppName的进程PROCESS=`ps -ef|grep $APP_NAME|grep -v grep |awk '&#123; print $2&#125;'`#循环停用进程直到成功while :do kill -9 $PROCESS &gt; /dev/null 2&gt;&amp;1 if [ $? -ne 0 ];then break else continuefidoneecho 'Stop Successed'#启动应用nohup /usr/java/jdk1.8.0_181/bin/java -jar $APP_NAME &gt;&gt;logs/start.log 2&gt;&gt;logs/startError.log &amp;#sleep等待15秒后，判断包含AppName的线程是否存在sleep 15if test $(pgrep -f $APP_NAME|wc -l) -eq 0then echo "Start Failed"else echo "Start Successed"fi 5、构建点击立即构建即可进行项目构建，构建完成后，构建记录的图标会根据构建结果不同显示成不同颜色。 蓝色、黄色、红色分别表示：成功、未完成、失败 如果构建并没有成功，可以点击构建记录，在后在控制台输出中查看构建记录 五 ，视频演示成果]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis缓存与memcache的区别]]></title>
    <url>%2F2020%2F04%2F29%2Fredis%2Fredis%E7%BC%93%E5%AD%98%E4%B8%8Ememcache%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数据结构方面 redis有更丰富的数据结构，可以满足不同的业务需求。而memcache需要客户端将数据获取再修改再set回去，增加网络io和系统开销。 内存使用方面 使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 性能对比 由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。 数据类型支持不同Redis支持的数据类型有：String、Hash、List、Set和Sorted Set。Redis内部使用一个redisObject对象来表示所有的key和value。 redisObject最主要的信息如图所示： type代表一个value对象具体是什么数据类型，encoding表示不同数据类型在redis内部的存储方式，比如：type=String代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际redis内部是按数值类型存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:”123″ “456”这样的字符串。只有打开了Redis的虚拟内存功能，vm字段才会真正的分配内存，该功能默认是关闭状态的。 1）String 常用命令：set/get/decr/incr/mget等； 应用场景：String是最常用的一种数据类型，普通的key/value存储都可以归为此类； 实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。 2）Hash 常用命令：hget/hset/hgetall等 应用场景：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日； 实现方式：Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。如图所示，Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。 3）List 常用命令：lpush/rpush/lpop/rpop/lrange等； 应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现； 实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。 4）Set 常用命令：sadd/spop/smembers/sunion等； 应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以去重，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的； 实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速去重，这也是set能提供判断一个成员是否在集合内的原因。 5）Sorted Set 常用命令：zadd/zrange/zrem/zcard等； 应用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 内存管理机制不同对于像Redis和Memcached这种基于内存的数据库系统来说，内存管理的效率高低是影响系统性能的关键因素。传统C语言中的malloc/free函数是最常用的分配和释放内存的方法，但是这种方法存在着很大的缺陷：首先，对于开发人员来说不匹配的malloc和free容易造成内存泄露；其次频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率；最后作为系统调用，其系统开销远远大于一般函数调用。所以，为了提高内存的管理效率，高效的内存管理方案都不会直接使用malloc/free调用。Redis和Memcached均使用了自身设计的内存管理机制，但是实现方法存在很大的差异，下面将会对两者的内存管理机制分别进行介绍。 Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。Slab Allocation机制只为存储外部数据而设计，也就是说所有的key-value数据都存储在Slab Allocation系统里，而Memcached的其它内存请求则通过普通的malloc/free来申请，因为这些请求的数量和频率决定了它们不会对整个系统的性能造成影响Slab Allocation的原理相当简单。 如图所示，它首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class。其中，Chunk就是用来存储key-value数据的最小单位。每个Slab Class的大小，可以在Memcached启动的时候通过制定Growth Factor来控制。假定图中Growth Factor的取值为1.25，如果第一组Chunk的大小为88个字节，第二组Chunk的大小就为112个字节，依此类推。 当Memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中。从以上过程我们可以看出Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。如下图所示，将100个字节的数据存到128个字节的Chunk中，剩余的28个字节就浪费掉了。 Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。如图所示，real_ptr是redis调用malloc后返回的指针。redis将内存块的大小size存入头部，size所占据的内存大小是已知的，为size_t类型的长度，然后返回ret_ptr。当需要释放内存的时候，ret_ptr被传给内存管理程序。通过ret_ptr，程序可以很容易的算出real_ptr的值，然后将real_ptr传给free释放内存。 Redis通过定义一个数组来记录所有的内存分配情况，这个数组的长度为ZMALLOC_MAX_ALLOC_STAT。数组的每一个元素代表当前程序所分配的内存块的个数，且内存块的大小为该元素的下标。在源码中，这个数组为zmalloc_allocations。zmalloc_allocations[16]代表已经分配的长度为16bytes的内存块的个数。zmalloc.c中有一个静态变量used_memory用来记录当前分配的内存总大小。所以，总的来看，Redis采用的是包装的mallc/free，相较于Memcached的内存管理方法来说，要简单很多。 数据持久化支持Redis提供两种持久化策略：RDB快照和AOF日志。而memcached不支持数据持久化。 1）RDB快照 Redis支持将当前数据的快照存成一个数据文件的持久化机制，即RDB快照。但是一个持续写入的数据库如何生成快照呢？RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。 可以通过Redis的save指令来配置RDB快照生成的时机，比如配置10分钟就生成快照，也可以配置有1000次写入就生成快照，也可以多个规则一起实施。这些规则的定义就在Redis的配置文件中，你也可以通过Redis的CONFIG SET命令在Redis运行时设置规则，不需要重启Redis。 Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的，当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件，这样在任何时候出现故障，Redis的RDB文件都总是可用的。RDB的缺点，就是一旦数据库出现问题，我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢失。 2）AOF日志 AOF 优点： 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据。 AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 AOF 缺点 对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 集群管理的不同Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。 Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。下图给出了Memcached的分布式存储实现架构。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。 相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。下图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。 为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全网实用软件合集包含各类(游戏，模拟器,应用......)]]></title>
    <url>%2F2020%2F04%2F25%2Fsoftware%2Fsoft_all_internet%2F</url>
    <content type="text"><![CDATA[各类实用软件合集一 .游戏类实用工具合集 应用名称 下载地址(蓝奏云地址) 刺激战场画质助手 超清画质次次吃鸡 https://lanzous.com/hzgjx 王者技能线 从此不再空技能 https://lanzous.com/wzryj 我的世界优化版去除无用资源，下载游戏就能玩，解锁所有皮肤！ https://lanzous.com/wodes 皇室战争无限资源版本，无限钻石！ https://lanzous.com/zhanz 二.应用类软件工具合集1.模拟器类合集 应用名称 下载地址(蓝奏云地址浏览器打开自动下载) 小鸡模拟器-破改版 一款最全的掌机模拟器游戏APP https://lanzous.com/xiaoj 2.社交类软件合集 应用名称 下载地址(蓝奏云地址浏览器打开自动下载) 企鹅助手 汇聚各种玩Q功能 https://lanzous.com/qerzs QQ『美化包』8.33 简约红破口令 ‖ 破闪照 ‖ 防撤回破语音 ‖ 防冻结 ‖ 破表情 https://lanzous.com/ic4z8uj QQ签到助手 一键完成签到 https://lanzous.com/qiand QQ自定义在线 法拉利在线 https://lanzous.com/zdyzs 祖安对线机 Q微信自动怼人 https://lanzous.com/zndxj 短信烘榨鸡 https://lanzous.com/ibkpxih 南瓜影视 https://lanzous.com/ibl0a8f QQ美化包8.3.6破口令 ‖ 破闪照 ‖ 防撤回破语音 ‖ 防冻结 ‖ https://lanzous.com/icxge0f 微信语音、QQ语音导出 https://ithuige.lanzous.com/id3f3hg 3.漫画类软件合集 应用名称 下载地址(蓝奏云地址浏览器打开自动下载) 触动漫画【一款漫画APP，超多经典热门漫画免费看】 https://lanzous.com/ic9ffwd 知音漫客【直装破解可以看所有最新漫画的章节】 https://lanzous.com/ibyn84f 4.小说类软件合集 应用名称 下载地址(蓝奏云地址浏览器打开自动下载) 蜜桃小说【非常强大的神器！对接全网海量书源 https://lanzous.com/ic915qd 5.追剧影视类软件合集 应用名称 下载地址(蓝奏云地址浏览器打开自动下载) U5影视聚合全球院线资源 https://lanzous.com/yings 剧汇TV官方版 http://ylj.rjjd6.com/1BFH0M 光影 https://ithuige.lanzous.com/ichmfne pp猪影视 http://www.ppzhu.vip/ 花样影视 https://i.hyys.me/ 小小影视 http://www.wangdunwen.com/?inviteCode=ICU7HI 6.其他工具类合集 应用名称 下载地址(蓝奏云地址浏览器打开自动下载) WiFi密码查看 一款免费的wifi密码显示软件 https://lanzous.com/chaka 西瓜分身（虚拟定位，模拟记性等） https://lanzous.com/icwn9of 三.科学上网类及慈善机场类网站合集(你再也不怕访问不了谷歌了)稳定白嫖VPN 蚂蚁加速器(邀请10个人免费无限流量很稳)有win,mac,andirond,iphone多端 https://ss.lanshuapi.com ===============机场推荐（排名不分前后）======================比特云：https://bit.ly/2UUSdWU (可白嫖 全中转 全V2 油管8W+)DLK：https://bit.ly/2yaiDw5 （高峰测速全红 定制全平台客户端)红莓：https://bit.ly/3ekTdMC （全网首家Trojan机场 众多IPEL专线）杰西卡：https://bit.ly/2V7vlVl （老牌 节点个个是精品）代号9：https://bit.ly/2Ru7EnR (高速8K注册就送50G 不限时长使用)追风岛：http://bit.ly/2Squ8qX （油管平均5W+ 1元/月）2ray：https://bit.ly/2XhfF3g ( 全中转 油管9W+)樱云：https://bit.ly/2wyuH9Q （免费公益机场)XIXICATS:https://bit.ly/2y0pDLC (高速免费公益 速度快)v2box:https://bit.ly/2UNibwl (7折优惠码：30OFF)light-up点亮:https://bit.ly/3bEbQJB (全遂道8K机场)无界VPN:https://bit.ly/2y2xgBj (高速 全中转机场)J20:http://bit.ly/2UgAoRE (高速 全中转机场)艾可云：http://bit.ly/2SI0j3T （免费订阅）跑路机场：http://bit.ly/2tv6cJk （稳定可靠 提供免流量节点）闪电机场：http://bit.ly/37YuNFc （完全免费公益的机场）酷鹰机场：http://bit.ly/31By4YO （免费节点多都可以NETFILX）bigheadplus:http://bit.ly/2Qk5UNi (中高端，专职客服)云域机场：http://bit.ly/2U7DNCb （低倍率节点支持）星梦数据：http://bit.ly/2TEoYId （超级牛逼的机场）有顶天：http://bit.ly/2wv3h4p (免费网飞账号支持流媒体及pcr日服)新加坡边际加速：http://bit.ly/3cDNK2G （月可白嫖5G的流量）最速：http://bit.ly/2uKJD3A口罩云N95：http://bit.ly/2IaOKNP （注册就送100G 免费节点油管50000+）道长鸡场：http://bit.ly/2TVdMYe 邀请码: bluemango司徒云：http://bit.ly/3aglxgf崽崽云：http://bit.ly/2w5DOhR91ssr极速云：http://bit.ly/2Ir5sIL （50个免费月卡，油管评论区送出）抖音热：http://bit.ly/32s3hxW （国际抖音专用机场）BYwave机场：http://bit.ly/38xQzzA100元机场：http://bit.ly/2vhYmUl （人少速度快）浪花云地址：http://bit.ly/2uA0gP4TED加速云：http://bit.ly/2TuJR8R搬瓦工官方鸡场:http://bit.ly/37u6Oxs （优惠码：JMS9272283 不怕IP被封的机场）====IPLC-NAT中转小鸡=====AKKO:http://bit.ly/31Ba73O套路云：http://bit.ly/391qXf8修罗去：http://bit.ly/2SDSTjqPQS：http://bit.ly/39DxtIP碳云：http://bit.ly/2wcRV4FNecoVM:http://bit.ly/2I3VxsxOVZ:http://bit.ly/2VWwmjX=======================VPS推荐======================搬瓦工：http://bit.ly/30S41M6 （10G端口 GIA %6折扣：BWH34QMFYT2R ）justhost:http://bit.ly/39bZtDc (机场主 俄罗斯节点首选 性价比高)digital-vm: http://bit.ly/3b0EjJN (10G端口 不限流量)hosteons:http://bit.ly/38H5dEM （机场必选）cloudcone:http://bit.ly/30S3Z6W （机场必选 灵活）VULTR:http://bit.ly/2TZNIeC （充10刀送100刀）PR：http://bit.ly/2TYadR2 （力推 建站首选）HOSTDARE：http://bit.ly/36nIWu0 （CN2 GIA机场必选）TMHHOST:http://bit.ly/3cgVOGw (CN2 GIA)绿帽云:http://bit.ly/37MNniR狗云：http://bit.ly/2PB9AKd===============更多精彩视频==================小白翻墙系列：http://bit.ly/2RDAjWPyoutuber必备：http://bit.ly/2RY3295 应用收集来自于网上仅供学习实用，切勿用于非法用途]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓取PC端数据包]]></title>
    <url>%2F2020%2F04%2F16%2FFiddler%E6%8A%93%E5%8F%96PC%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Fiddler抓取PC端数据包：这里 Fiddler 抓取网页客户端的数据包时，其原理就是在 客户端/浏览器 和 服务器端 之间，加上了一个 Fiddler 代理服务器，在数据包在客户端和服务器端进行传递时，会被处于中间代理的 Fiddler 代理服务器记录下来。 首先，我们启动 Fiddler 抓包工具，这个时候，一般情况下，代理会自己开启，不用进行额外的网络设置，我们打开一个 Chrome 浏览器，进行访问百度等网页，就会在 Fiddler 中出现浏览的数据包。如果发现这里抓不到数据包，我们需要进行排查一下： 1）排查我们的网络代理是否开启了； 我们打开浏览器，这里以 Chrome 浏览器为例，我们可以看到 Chrome 浏览器设置中高级设置，找到打开代理设置选项： 这里的代理服务器，默认是不勾选的，然后我们打开 fiddler 抓包工具，可以看到这里的代理服务器设置被默认开启： 这个时候，我们就能抓取到数据包了。 2）排查Fiddler自身设置抓取 HTTPS 协议包； 打开 Fiddler，点击工具栏中的 Tools—&gt; Options，切到Https页签，勾选选项： 然后切换到 Connections 页签，勾选下面选项，这里的端口默认是 8888 端口： 3）排查浏览器版本； 这里建议安装最新版本的浏览器，可以避免一些奇怪的莫名错误。 4）证书安装； 证书安装这里自行百度，一般安装fiddler时会自动安装上。 Fiddler抓取移动端数据包：1）打开 fiddler，点击菜单栏中的 Tools —&gt; Fiddler Options； 2）选中 Connections 页签，设置代理端口号为8888，勾选 Allow remote computer to connect，点击 OK，然后重启 Fiddler； 3）cmd进入到电脑dos界面，输入 ipconfig 命令，查看电脑的 ip 地址； 4）在手机端链接同网段内的WiFi，然后设置代理IP和端口号一致； 5）然后在手机浏览器中，输入 IP:端口号，下载Fiddler的证书进行安装； 6）证书安装完成后，就可以用手机进行访问，然后在 Fiddler 中就可以看到手机访问的数据包了； Fiddler抓取模拟器数据包：模拟器的基本原理和移动端相似，就是相当于在电脑上操作一个模拟的手机端。 1）Fiddler设置和上面提到的是一样的，进行设置即可； 2）打开模拟器，找到模拟器中链接网络的WLAN信号，进行长按修改网络； 3）点击修改网络弹出界面中的“显示高级选项”设置，然后代理选择“手动”，代理服务器主机名和端口号，就用上面我们查询到的即可，然后保存； 4）保存后，同样的，用模拟器的浏览器访问 ip地址:代理端口号，如：http://192.168.20.107:8888，然后下载 Fiddler 安全证书进行安装； 5）安装完证书后，需要取一个名字，名字随便去一个就行了，然后到这一步，Fiddler就可以对我们设置过后的模拟器进行抓包了。 fiddler小知识–会话属性及其图标的含义 在测试的过程中，我们经常会用到抓包工具–Fiddler，用来抓取网络数据包，从而用来帮助定位Bug。对于 Fiddler 会话列表中，这里对其列表中的会话的属性及其图标的含义，做一个简单的整理小结。 1.会话属性#：为了方便查找和定位而自动生成的自增数列 id，从1开始递增。 Result：网络协议相应的结果编码。 Protocol：会话使用的协议类型，如：HTTP，HTTPS，FTP等。 Host：网络请求发送到的服务器主机名。 URL：服务器中的路径和文件。 Body：响应 body 的字节数，以 bytes 为单位。 Caching：响应的有效期或Cache-Control标头的值。 Content-Type：响应的Content-Type标头。 Process：发起流量数据包的本地 Windows 进程。 Comments：注释，可以从脚本或会话的上下文菜单设置的文本。 Custom：自定义，可设置脚本的文本。 2.会话图标（图片来源于网络）]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Admin使用]]></title>
    <url>%2F2020%2F04%2F12%2FAdmin%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常见的功能或者监控如下： 显示健康状况 显示详细信息，例如 JVM和内存指标 micrometer.io指标 数据源指标 缓存指标 关注并下载日志文件 查看jvm系统和环境属性 查看Spring Boot配置属性 支持Spring Cloud的postable / env-和/ refresh-endpoint 轻松的日志级管理 与JMX-beans交互 查看线程转储 查看http跟踪 查看auditevents 查看http-endpoints 查看计划任务 查看和删除活动会话（使用spring-session） 查看Flyway / Liquibase数据库迁移 下载heapdump 状态变更通知 部署SpringBoot Admin Server，输入用户名密码进入控制台 一.SpringBoot Admin Server控制台1.1.应用墙查看注册中心上所有的微服务，每个服务部署了多少个实例，可以点击任意一个服务进入看这个服务的监控信息 1.2.服务详情点击服务，查看服务监控信息 1.3线上jvm信息如果发生oom或者死锁等问题，可以下载堆栈信息定位问题 二.客户端接入(微服务)所有服务接入也非常简单，只需要引入几个依赖和新增配置即可 2.1项目引入依赖 ​ de.codecentric​ spring-boot-admin-starter-client​ 2.1.0​ 2.2新增配置开放endpoint, 在SpringBoot2.x中，默认只开放了info、health两个端点，剩余的需要自己通过配置management.endpoints.web.exposure.include属性来加载,在项目application.yaml文件中新增配置 management: endpoints: ​ web: ​ base-path: / ​ exposure: #默认情况下，大多数actuator的端口都不会通过http公开，* 代表公开所有这些端，开#发环境可以全部打开 ​ include: ‘*’ endpoint: ​ health: ​ show-details: A**LWAYS spring: boot: ​ admin: ​ client: ​ instance: #通过ip来替换hostname ​ prefer-ip: true 2.3.检查是否生效去控制台检查是否生效]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 下安装部署 Jenkins教程]]></title>
    <url>%2F2020%2F02%2F01%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2FCentOS-7%E4%B8%8B%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-Jenkins%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、前言 1、 Jenkins是什么？Jenkins是一个开源的支持自动化构建、部署等任务的平台。基本上可以说是持续集成（CI）、持续发布（CD）不可或缺的工具。 官网：https://jenkins.io/ 2、本篇环境信息 工具/环境 版本 Linux Server CentOS 7 Jenkins 2.121.2 JDK 1.8.0_181 3、准备工作安装JDK1、下载123456#JDK下载首页http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html#JDK8历史版本https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html#（1）下载之后FTP/SFTP到服务器#（2）获取到下载链接后，用wget命令下载 2、解压到指定目录12sudo mkdir -p /usr/java sudo tar zvxf jdk-8u131-linux-x64.tar.gz -C /usr/java 3、配置环境变量123456vi /etc/profile# 在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL下添加export JAVA_HOME=/usr/java/jdk1.8.0_131export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 4、使环境变量生效1source /etc/profile 5、检查是否配置成功1java -version 二、Jenkins安装1、Yum安装 yum源导入 12345#添加Yum源sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo#导入密钥sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 安装 1sudo yum install -y jenkins 2、开放端口Jenkins站点的默认监听端口是8080 12sudo firewall-cmd --add-port=8080/tcp --permanentsudo firewall-cmd --reload 3、配置Java可选路径因为Jenkins默认的java可选路径不包含我们部署的jdk路径，所以这里要配置一下，不然Jenkins服务会启动失败 12345678910111213#修改jenkins启动脚本sudo vi /etc/init.d/jenkins#修改candidates增加java可选路径：/usr/java/jdk1.8.0_181/bin/javacandidates="/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java/usr/java/jdk1.8.0_181/bin/java" 4、启动Jenkins并设置Jenkins开机启动123456789#重载服务（由于前面修改了Jenkins启动脚本）sudo systemctl daemon-reload#启动Jenkins服务sudo systemctl start jenkins#将Jenkins服务设置为开机启动#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令sudo /sbin/chkconfig jenkins on 浏览器输入 http://你虚拟机的ip:8080 访问Jenkins 5,第一次启动需要输入密码密码默认在/root/.jenkins/ssecrets/initiaAdminPassword 6、插件安装修改默认插件源注：（vi /root/.jenkins/hudson.model.UpdateCenter.xml） 打开 hudson.model.UpdateCenter.xml 把 http://updates.jenkins-ci.org/update-center.json 改成 :（以下其中一个） http://mirror.xmission.com/jenkins/updates/update-center.json https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json http://mirror.esuni.jp/jenkins/updates/update-center.json ，还是不行的话找到 updates 目录下的 default.json 把里面所有的谷歌地址改成百度的，即将 http://www.google.com/ 替换为 http://www.baidu.com/。输入密码后出现以下界面说明成功。 ，还是不行的话找到 updates 目录下的 default.json 把里面所有的谷歌地址改成百度的，即将 http://www.google.com/ 替换为 http://www.baidu.com/。输入密码后出现以下界面说明成功。 配置完成出现以下界面说明url配置完成！ 3.推荐插件安装 4.创建用户 5.实例配置 6.开始使用 7.进入首页 至此、Jenkins的下载安装，完成]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis缓存]]></title>
    <url>%2F2020%2F01%2F16%2Fredis%2Fredis%2F</url>
    <content type="text"><![CDATA[安装、主从复制 redis缓存与memcache的区别 redis原生命令api redis 命令参考 Redis 教程 redis缓存附录 安装、主从复制 redis缓存与memcache的区别 redis原生命令api redis 命令参考 Redis 教程 redis cluster Redis 集群教程 Redis Cluster集群搭建 客户端： Jedis github源码 Redic Redis缓存客户端，支持读写分离和分片。 源码 Codis 在应用层和缓存服务器中间增加一个代理层，根据分片规则来路由请求。 Codis集群的搭建与使用 资料收集： redis为什么是单线程？ Redis为什么这么快？一文深入了解Redis内存模型！ 3台机器轻松搭建一个高可用Redis服务架构 Redis 内存为什么不宜过大 史上最全Redis高可用技术解决方案大全 业务应用： 同程凤凰缓存系统基于Redis的设计与实践 携程开源其Redis多数据中心解决方案XPipe 前沿： redis不同版本新特性 redis采用C编写，redis服务器是核心业务采用单线程模式，无锁竞争且基于内存操作，执行效率非常高。 如果开启备份机制，会fork子线程来处理。 12用的比较多的redis客户端jedis：https://github.com/xetorthio/jedis 核心逻辑：12345678910111213141516protected Connection sendCommand(final Command cmd, final byte[]... args) &#123;try &#123; //建立连接，包装RedisOutputStream和RedisInputStream connect(); //发送执行命令 Protocol.sendCommand(outputStream, cmd, args); lastAccessTime = System.currentTimeMillis(); pipelinedCommands++; return this;&#125; catch (JedisConnectionException ex) &#123; System.err.println(ex.getMessage()); // Any other exceptions related to connection? broken = true; throw ex;&#125; &#125; Command内提供了多种redis操作命令。 12public static enum Command &#123;PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, ZLEXCOUNT, ZRANGEBYLEX, ZREMRANGEBYLEX, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE; 1234567public String set(final String key, final String value, final String nxxx, final String expx, final long time) &#123;checkIsInMulti();client.set(key, value, nxxx, expx, time);//返回结果return client.getStatusCodeReply(); &#125; 不同类型长度限制： string 最大512M List 最大长度 （2的32次方-1）,有序可重复 Sets 最大长度 （2的32次方-1），不允许重复，自动去重 Sorted sets，同上，支持按score排序 Hashes kv对数（2的32次方-1） 内部方法详解：1.String String setBin(String key, byte[] value) 按字节数组关联到key下 byte[] getBin(String key) 根据key查找对应下的字节数组 String set(String key, String value) 将字符串值value关联到key String get(String key) 返回key所关联的字符串值,如果key不存在则返回null long setnx(String key, String value) 将字符串值value关联到key，如果key已存在则不做任何改变。返回1表示key不存在，第一次设置；返回0表示key已经存在 String setex(String key, int seconds, String value) 将值value关联到key，并将key的生命周期设为seconds(以秒为单位)。如果key 已经存在，SETEX命令将覆写旧值。 long append(String key, String value) 如果key已经存在并且是一个字符串，APPEND命令将value追加到key原来的值之后如果key不存在，APPEND就简单地将给定key设为value，同 SET key value long strlen(String key) throws RedisException; 获取key所对应的value字符串长度 long incr(String key) 将key中储存的数字值加1,如果key不存在,以0为key的初始值,然后执行INCR操作。线程安全 long incrBy(String key, long n) 将key中储存的数字值加n,如果key不存在,以0为key的初始值,然后执行INCRBY操作 long decr(String key) 将key中储存的数字值减1,如果key不存在,以0为key的初始值,然后执行DECR操作。 long decrBy(String key, long n) 将key中储存的数字值减n,如果key不存在,以0为key的初始值,然后执行DECRBY操 String getSet(String key, String value) 设置key为当前值，并返回旧的值 String set(String key, String value, String nxxx, String expx, long time) throws RedisException; 12345678将字符串值value关联到key:nxxx：必须是NX或者XX，NX表示不存在则设置否则不做操作；XX表示存在才设置否则不做操作expx：过期时间单位必须是EX或PX，EX表示单位是“秒”，PX表示单位是“毫秒”time：过期时间，前一个参数是&quot;EX&quot;的话单位为“秒”，是&quot;PX&quot;的话单位为“毫秒”@return 操作成功的话返回字符串OK，否则返回nullps：从Redis 2.6.12 版本开始支持 2.ListRedis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同 long lpush(String key, String value) 将值value插入到列表key的表头。 如果key不存在，一个空列表会被创建并执行LPUSH操作 long lpushBin(String key, byte[] value) 同上 long rpush(String key, String value) 将值value插入到列表key的表尾。 如果key不存在，一个空列表会被创建并执行RPUSH操作 long rpushBin(String key, byte[] value) 同上 String lpop(String key) 移除并返回列表key的头元素 byte[] lpopBin(String key) 同上 String rpop(String key) 移除并返回列表key的尾元素 byte[] rpopBin(String key) 同上 long llen(String key) 计算列表长度 List lrange(String key, long start, long end) 返回列表key中指定区间内的元素，[start,end]，区间为0开始 String ltrim(String key, int start, int end) 列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除 long lrem(final String key, final long count, final String value) 根据参数count的值，移除列表中与参数value相等的元素count的值可以是以下几种：count &gt; 0: 从表头开始向表尾搜索，移除与value相等的元素，数量为count count &lt; 0: 从表尾开始向表头搜索，移除与value相等的元素，数量为count的绝对值 count = 0: 移除表中所有与value相等的值 3.Set long sadd(String key, String member) 将member单个元素加入到集合key当中 long sadd(String key, String… members) 将members元素数组加入到集合key当中 long srem(String key, String member) 移除集合中的member元素 long scard(String key) 集合中元素的数量 Set smembers(String key) 返回set中的所有元素 4.sorted set long zadd(String key, double score, String member) 将member元素及其score值加入到有序集key当中 double zincrby(String key, double score, String member) 对member元素增加score值 long zrem(String key, String member) 移除有序集合key中的成员member，如果member不是有序集中的成员，不做任何操作 long zremrangeByScore(String key, double start, double end) 删除的有序集合保存在key的最小值和最大值(含)之间的分数的所有元素 long zcard(String key) 集合长度 long zcount(String key, double min, double max) 有序集key中，score值在min和max之间的成员数量 double zscore(String key, String member) 有序集key中，成员member的score值 long zrank(String key, String member) 返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列排名以0为底，也就是说，score值最小的成员排名为0 Set\ zrange(String key, int start, int end) 返回索引区间之间的元素，最小元素索引号为0，[start,end] Set\ zrangeByScore(String key, double min, double max) 返回分数之间的元素,[min,max] Set\ zrangeByScore(String key, double min, double max, int offset, int count) 分数由小到大的顺序，取[min,max]之间的数据，offset表示取数据的开始位置（O：表示最小分数的那个位置），最多返回count个结果 long zrevrank(String key, String member) 返回有序集key中成员member的排名。其中有序集成员按score值递减(从大到小)排序排名以0为底，也就是说，score值最大的成员排名为0 Set\ zrevrange(String key, int start, int end) 返回索引区间之间的元素，最大元素索引号为0,[start,end] Set\ zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count) 分数按大到小的顺序，取[min,max]之间的数据，offset表示取数据的开始位置（O：表示最大分数的那个位置），最多返回count个结果，Tuple包含分数、value值等信息。 5.Hash long hset(String key, String field, String value) 将哈希表key中的域field的值设为value,如果key不存在，一个新的哈希表被创建并进行HSET操作。 long hsetBin(String key, String field, byte[] value) 同上 long hsetnx(String key, String field, String value) 将哈希表key中的域field的值设为value，如果key已经存在，不做任何处理 String hmset(String key, Map&lt;String, String&gt; hash) 同时将多个field - value(域-值)对设置到哈希表key中 String hget(String key, String field) 返回哈希表key中给定域field的值 byte[] hgetBin(String key, String field) 同上 Map&lt;String, String&gt; hgetAll(String key) 返回哈希表key中，所有的域和值 List hmget(String key, String… fields) 返回哈希表key中，一个或多个给定域的值，一一对应的如果给定的域不存在于哈希表，那么返回一个null. long hlen(String key) 返回Hash表中的元素个数 Set hkeys(String key) 返回Hash表中的keys List hvals(String key) 返回Hash表中的values boolean hexists(String key, String field) 哈希表key中，给定域field是否存在 long hdel(String key, String field) 删除哈希表key中的一个指定域 long hincrBy(String key, String field, long value) 对哈希中的某个key对应的值增加计数，线程安全。如果field不存在，初始值为0 lua 脚本如果一次业务请求需要执行多条命令，可以借助lua脚本批量提交执行 123456789101112131415// key：缓存键值； seconds：过期时间public static String luaScript(String key, long seconds) &#123; return &quot;local currIncr = redis.call(&apos;INCR&apos;, &apos;&quot; + key + &quot;&apos;) &quot; + &quot;if tonumber(currIncr) == 1 &quot; + &quot;then &quot; + &quot;redis.call(&apos;EXPIRE&apos;, &apos;&quot; + key + &quot;&apos;, &quot; + seconds + &quot;) &quot; + &quot;end &quot; + &quot;return currIncr&quot;;&#125;//寻找目标节点Node target = redisClient.getNodeByKey(key);//执行lua脚本命令Long count = (Long) redisClient.eval(target, luaScript方法返回的字符串命令); 参考资料http://zhangtielei.com/posts/server.html https://www.zhihu.com/question/19764056 http://www.redis.cn/ http://ifeve.com/category/redis/]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis安装及主从复制]]></title>
    <url>%2F2019%2F12%2F12%2Fredis%2Fredis-master-slave%2F</url>
    <content type="text"><![CDATA[Redis安装及主从复制 一、安装下载安装包https://redis.io/download 解压1tar zxvf redis-4.0.2.tar.gz 编译源程序12cd redis-4.0.2-6379make 服务启动12cd src./redis-server &amp; 查看一下启动的Redis实例1ps -ef|grep redis 客户端shell12cd src./redis-cli 配置参数(redis.conf)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849daemonize：如需要在后台运行，把该项的值改为yes pdifile：把pid文件放在/var/run/redis.pid，可以配置到其他地址 bind：指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项 port：监听端口，默认为6379 timeout：设置客户端连接时的超时时间，单位为秒 loglevel：等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice logfile：配置log文件地址，默认使用标准输出，即打印在命令行终端的端口上 database：设置数据库的个数，默认使用的数据库是0 save：设置redis进行数据库镜像的频率 rdbcompression：在进行镜像备份时，是否进行压缩 dbfilename：镜像备份文件的文件名 dir：数据库镜像备份的文件放置的路径 slaveof：设置该数据库为其他数据库的从数据库 masterauth：当主数据库连接需要密码验证时，在这里设定 requirepass：设置客户端连接后进行任何其他指定前需要使用的密码 maxclients：限制同时连接的客户端数量 maxmemory：设置redis能够使用的最大内存 appendonly：开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态 appendfsync：设置appendonly.aof文件进行同步的频率 vm_enabled：是否开启虚拟内存支持 vm_swap_file：设置虚拟内存的交换文件的路径 vm_max_momery：设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0 vm_page_size：设置虚拟内存页的大小 vm_pages：设置交换文件的总的page数量 vm_max_thrrads：设置vm IO同时使用的线程数量 二、主从复制 主从复制原理 单机启动三个实例，一主两从。创建三个目录，分别是6379、6380、6381，创建conf、log、db三个目录，并拷贝redis.conf到对应的conf目录下 （master）修改6379/conf 目录下的redis.conf 配置 12345daemonize yes &lt;== daemon进程运行pidfile /Users/onlyone/software/redis/6379/redis.pid &lt;== 进程id存放文件port 6379 &lt;== 端口logfile /Users/onlyone/software/redis/6379/log/redis.log &lt;== 日志目录dir /Users/onlyone/software/redis/6379/db/ &lt;== db目录 （slave） 修改6380/conf 目录下的redis.conf 配置 123456daemonize yes &lt;== daemon进程运行pidfile /Users/onlyone/software/redis/6380/redis.pid &lt;== 进程id存放文件port 6380 &lt;== 端口logfile /Users/onlyone/software/redis/6380/log/redis.log &lt;== 日志目录dir /Users/onlyone/software/redis/6380/db/ &lt;== db目录slaveof 127.0.0.1 6379 &lt;== master机器 （slave） 修改6381/conf 目录下的redis.conf 配置 123456daemonize yes &lt;== daemon进程运行pidfile /Users/onlyone/software/redis/6381/redis.pid &lt;== 进程id存放文件port 6381 &lt;== 端口logfile /Users/onlyone/software/redis/6381/log/redis.log &lt;== 日志目录dir /Users/onlyone/software/redis/6381/db/ &lt;== db目录slaveof 127.0.0.1 6379 &lt;== master机器 启动实例 123./redis-server /Users/onlyone/software/redis/6379/conf/redis.conf &amp; ./redis-server /Users/onlyone/software/redis/6380/conf/redis.conf &amp; ./redis-server /Users/onlyone/software/redis/6381/conf/redis.conf &amp; 查看进程信息 12345ps -ef|grep redis501 32933 1 0 10:24上午 ?? 0:00.25 ./redis-server 127.0.0.1:6380 501 32986 1 0 10:27上午 ?? 0:00.09 ./redis-server 127.0.0.1:6381 501 32880 12633 0 10:22上午 ttys000 0:00.43 ./redis-server *:6379 查看master节点信息 123456789101112131415161718./redis-cli -p 6379 &quot;info&quot;。。。省略。。。\# Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6380,state=online,offset=518,lag=1slave1:ip=127.0.0.1,port=6381,state=online,offset=518,lag=1master_replid:38605ae9c8d326685b9d114b31efffc405b54129master_replid2:0000000000000000000000000000000000000000master_repl_offset:518second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:518。。。省略。。。 查看slave（6380）节点信息 123456789101112131415161718192021222324./redis-cli -p 6380 &quot;info&quot;。。。省略。。。\# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:10master_sync_in_progress:0slave_repl_offset:658slave_priority:100slave_read_only:1connected_slaves:0master_replid:38605ae9c8d326685b9d114b31efffc405b54129master_replid2:0000000000000000000000000000000000000000master_repl_offset:658second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:658。。。省略。。。 主库写数据 123456➜ src ./redis-cli -p 6379127.0.0.1:6379&gt; set name tomOK127.0.0.1:6379&gt; get name&quot;tom&quot;127.0.0.1:6379&gt; 查看从库同步数据 1234➜ src ./redis-cli -p 6380127.0.0.1:6380&gt; get name&quot;tom&quot;127.0.0.1:6380&gt;]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[commons-io]]></title>
    <url>%2F2019%2F11%2F29%2Fcommons%2Fcommons-io%2F</url>
    <content type="text"><![CDATA[commons-io 封装了一些常用工具类方法，用于IO的各种操作: Utility class ，提供一些静态方法来满足一些常用的业务场景 Input ， InputStream 和 Reader 实现 Output ， OutputStream 和 Writer 实现 Filters ， 多种文件过滤器实现（定义了 IOFileFilter接口，同时继承了 FileFilter 和 FilenameFilter 接口） comparator包， 文件比较，提供了多种 java.util.Comparator 实现 pom依赖12345 &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 常用工具类 IOUtils 提供各种静态方法，用于处理读，写和、拷贝，这些方法基于InputStream、OutputStream、Reader 和 Writer 123456 InputStream in = new URL( &quot;http://commons.apache.org&quot; ).openStream();try &#123; System.out.println( IOUtils.toString( in ) );&#125; finally &#123; IOUtils.closeQuietly(in);&#125; FileUtils 提供各种静态方法，基于File对象工作，包括读、写、拷贝、比较文件 12 File file = new File(&quot;/commons/io/project.properties&quot;);List lines = FileUtils.readLines(file, &quot;UTF-8&quot;); LineIterator 提供灵活的方式操作基于行的文件。通过FileUtils 或 IOUtils中的静态方法，可以直接创建一个实例 123456789 LineIterator it = FileUtils.lineIterator(file, &quot;UTF-8&quot;);try &#123; while (it.hasNext()) &#123; String line = it.nextLine(); /// do something with line &#125;&#125; finally &#123; LineIterator.closeQuietly(it);&#125; 参考资料：http://ifeve.com/commons-io/]]></content>
      <categories>
        <category>common</category>
      </categories>
      <tags>
        <tag>common</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[commons-lang3]]></title>
    <url>%2F2019%2F10%2F29%2Fcommons%2Fcommons-lang3%2F</url>
    <content type="text"><![CDATA[commons-lang3 主要是提供一些基础的操作和处理，归为以下几类： org.apache.commons.lang3（高度重用的Util类，常用的工具类静态方法；重点） org.apache.commons.lang3.builder（忽略） org.apache.commons.lang3.concurrent（忽略） org.apache.commons.lang3.event（忽略） org.apache.commons.lang3.exception（忽略） org.apache.commons.lang3.math（数字类型转换、大小比较、是否数字 等相关工具类；重点） org.apache.commons.lang3.mutable（包装值型变量，为基础数据类型扩展了更多方法） org.apache.commons.lang3.reflect（反射相关，忽略） org.apache.commons.lang3.text（文本相关） org.apache.commons.lang3.time（处理日期和时间的功能；重点） org.apache.commons.lang3.tuple（忽略） pom依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt; 常用工具类：内容虽然有点多，但我们使用最多还是一些有用的包含static方法的Util类。 StringUtils – 处理String的核心类，提供了相当多的功能； NumberUtils - 类型转换（String-&gt;Long）；取最大最小值；比较大小。所有操作都不会抛出异常，如果转换不成功返回0,0.0d,0.0f等形式，转换操作也可以指定默认值。 DateUtils -日期相关；是否同一天；时间+x；字符串转换成Date ArrayUtils – 用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等； SystemUtils – 在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断； WordUtils – 用于处理单词大小写、换行等。 StringEscapeUtils – 用于正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码； CharRange – 用于设定字符范围并做相应检查； ClassUtils – 用于对Java类的操作，不使用反射； Validate – 提供验证的操作，有点类似assert断言； 参考资料：https://commons.apache.org/proper/commons-lang/javadocs/api-release/ http://zhoualine.iteye.com/blog/1770014]]></content>
      <categories>
        <category>common</category>
      </categories>
      <tags>
        <tag>common</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 下安装部署 GitLab社区版教程]]></title>
    <url>%2F2019%2F10%2F29%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2FCentOS7%E4%B8%8B%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-GitLab%E7%A4%BE%E5%8C%BA%E7%89%88%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、前言1、本文主要内容 GitLab11.1.4社区版部署 GitLab配置禁用创建组权限 GitLab配置邮件(SMTP) GitLab常用命令说明 先介绍一下本篇文章所使用的环境 服务器 服务器名 操作系统 硬件配置 虚拟机IP 说明 GitLab CentOS 7 1C4G 192.168.56.160 部署GitLab社区版 二、准备工作1、安准基础依赖#安装技术依赖 sudo yum install -y curl policycoreutils-python openssh-server #启动ssh服务&amp;设置为开机启动 sudo systemctl enable sshd sudo systemctl start sshd 2、安装PostfixPostfix是一个邮件服务器，GitLab发送邮件需要用到 #安装postfix sudo yum install -y postfix #启动postfix并设置为开机启动 sudo systemctl enable postfix sudo systemctl start postfix 3、开放ssh以及http服务（80端口）#开放ssh、http服务 sudo firewall-cmd –add-service=ssh –permanent sudo firewall-cmd –add-service=http –permanent #重载防火墙规则 sudo firewall-cmd –reload 三、部署过程本次我们部署的是社区版:gitlab-ce，如果要部署商业版可以把关键字替换为：gitlab-ee 1、Yum安装GitLab 添加GitLab社区版Package curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash 安装GitLab社区版 sudo yum install -y gitlab-ce 安装成功后会看到gitlab-ce打印了以下图形 2，浏览器输入 192.168.56.160就能进入到gitlab的登录界面了 这时候会提示为管理员账号设置密码。管理员账号默认username是root。 设置完成之后即可使用root账号登录，登陆后会进入欢迎界面。]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[commons-codec]]></title>
    <url>%2F2019%2F10%2F29%2Fcommons%2Fcommons-codec%2F</url>
    <content type="text"><![CDATA[commons-codec commons-codec是Apache下面的用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64，URL，Soundx等等。 不仅是编码，也可用于解码。 pom依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt;&lt;/dependency&gt; 常用工具类： DigestUtils工具类 提供了多种编码方式的静态方法，用于对String、byte[]、InputStream等类型的数据编码。 案例场景： 电子商务平台，买家对一件商品下单后，为了便于后面的纠纷处理，需要对下单那一时刻的商品信息备份（因为卖家随时会修改自己的宝贝信息），命名为快照。如果为每一个订单都保存一次商品详情显然不现实，DigestUtils可以很好解决这个问题。每次对整个商品详情数据编码得到一个32字符摘要，作为唯一id并关联到用户订单，并保存到数据库中。可以有效对快照去重，节省资源空间。 12345678910111213141516171819import org.apache.commons.codec.digest.DigestUtils;public class DigestTest &#123; public static void encodeStr(String data) &#123; String encodeS = DigestUtils.md5Hex(data); System.out.println(encodeS); &#125; public static void main(String[] args) &#123; String data = &quot;网销投连险是保险公司的一款保险产品，在互联网金融上还是很常见的。&quot; + &quot;比如京东天天盈，网易有钱零钱++。这些保险削弱了保险的保障功能，降低成本，从而提高保险的理财功能提高理财收益。&quot; + &quot;投连险基本和银行结构性理财产品一样，信息披露度不高，但是有保险公司兜底，不至于整个平台跑路。&quot; + &quot;投资投连险可以想象为投资一个起点低的银行理财产品吧。网销投连险一般都受益在4-6%，不承诺保本。&quot; + &quot;经常爆出保险公司的保障型长期投连险出现投资亏损新闻，但是网销短期投连险投资型投连险目前没有出现亏损，基本也能按照预期收益兑付。&quot; + &quot;网销投连险安全性和收益性都比较居中，短期产品危险系数不高，但是在债券违约的大环境下，长期产品安全性没有太大保障。&quot; + &quot;不过好在保险公司没有跑路风险，至少不会把本金损失殆尽啊。&quot;; encodeStr(data); &#125;&#125; 运行结果： 19901d04398f5b2adc0049c8c751e7411 参考资料：http://commons.apache.org/proper/commons-codec/userguide.html https://commons.apache.org/proper/commons-codec/apidocs/index.html]]></content>
      <categories>
        <category>common</category>
      </categories>
      <tags>
        <tag>common</tag>
      </tags>
  </entry>
</search>
